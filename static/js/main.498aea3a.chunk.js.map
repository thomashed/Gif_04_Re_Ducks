{"version":3,"sources":["state/ducks/gifs/reducers.js","state/ducks/gifs/types.js","state/ducks/gifs/operations.js","state/ducks/gifs/actions.js","state/ducks/gifs/index.js","views/containers/SearchGif.js","views/components/Gif.js","views/containers/GifsList.js","views/App.js","serviceWorker.js","state/store.js","index.js"],"names":["initialStateSearchField","searchField","initialStateRequestGifReducer","isPending","gifs","error","initialStateCopyGifReducer","currentCopiedGifUrl","reducer","combineReducers","changeSearchFieldReducer","state","action","type","Object","assign","payload","requestGifReducer","copyGifReducer","changeSearchField","searchString","sendRequestGif","dispatch","fetch","then","response","json","sortedData","data","forEach","gifObject","images","original","size","push","catch","clearGifsList","gifClicked","elementId","gifUrl","input","document","createElement","id","value","body","appendChild","select","setSelectionRange","execCommand","err","actions","removeChild","connect","gifsState","gifsOperations","className","onClick","onSubmit","e","preventDefault","trim","ref","node","placeholder","Gif","keyProp","urlOriginal","sizeOriginal","src","alt","map","gif","i","key","url","length","App","Component","Boolean","window","location","hostname","match","logger","createLogger","level","collapsed","reduxStore","initialState","rootReducer","reducers","createStore","applyMiddleware","ThunkMiddleware","configureStore","ReactDOM","render","store","getElementById","navigator","serviceWorker","ready","registration","unregister","console","message"],"mappings":"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","file":"static/js/main.498aea3a.chunk.js","sourcesContent":["// reducers are the only thing that updates our store(state of the app)\n// it's good practice to keep the state shape above the \nimport {combineReducers} from 'redux';\nimport * as types from './types';\n\n/* state shape, i.e. the props in our store and their types\n{\n    searchField: string\n}\n*/\n\n// TODO: is the below the best way to assign initial value of the store prop?\nconst initialStateSearchField = {\n    searchField: '42'\n}\n\nconst changeSearchFieldReducer = (state = initialStateSearchField, action = {}) => {\n    switch(action.type){\n        case types.CHANGE_SEARCH_FIELD:\n            return Object.assign({}, state, {searchField: action.payload});\n        case types.CLEAR_GIFS_LIST:\n            return Object.assign({}, state, {searchField: ''}); \n        default: return state;\n    }\n}\n\nconst initialStateRequestGifReducer = {\n    isPending: false,\n    gifs: [],\n    error: false\n}\n\nconst requestGifReducer = (state = initialStateRequestGifReducer, action = {}) => {\n    switch(action.type){\n        case types.REQUEST_GIF_PENDING:           \n            return Object.assign({}, state, {isPending: true});\n        case types.REQUEST_GIF_SUCCESS:   \n            return Object.assign({}, state, {isPending: false, gifs: action.payload});\n        case types.REQUEST_GIF_FAILED:           \n            return Object.assign({}, state, {isPending: false});\n        case types.CLEAR_GIFS_LIST:\n            return Object.assign({}, state, {gifs: action.payload});\n        default:\n            return state;\n    }\n}\n\nconst initialStateCopyGifReducer = {\n    currentCopiedGifUrl: '',\n    error: false\n}\n\nconst copyGifReducer = (state = initialStateCopyGifReducer, action = {}) => {\n    switch(action.type){\n        case types.COPY_GIF_SUCCESS:\n            return Object.assign({}, state, {currentCopiedGifUrl: action.payload});\n        case types.COPY_GIF_FAILED:\n            return Object.assign({}, state, {currentCopiedGifUrl: '', error: true});\n        default:\n            return state;\n    }\n}\n\n\nconst reducer = combineReducers({\n    changeSearchFieldReducer: changeSearchFieldReducer,\n    requestGifReducer: requestGifReducer,\n    copyGifReducer: copyGifReducer\n})\n\nexport default reducer;","const CHANGE_SEARCH_FIELD = 'CHANGE_SEARCH_FIELD';\nconst REQUEST_GIF_PENDING = 'REQUEST_GIF_PENDING';\nconst REQUEST_GIF_SUCCESS = 'REQUEST_GIF_SUCCESS';\nconst REQUEST_GIF_FAILED  = 'REQUEST_GIF_FAILED';\nconst CLEAR_GIFS_LIST     = 'CLEAR_GIFS_LIST';\nconst COPY_GIF_SUCCESS  = 'COPY_GIF_SUCCESS';\nconst COPY_GIF_FAILED  = 'COPY_GIF_FAILED';\n\nexport {\n    CHANGE_SEARCH_FIELD,\n    REQUEST_GIF_PENDING,\n    REQUEST_GIF_SUCCESS,\n    REQUEST_GIF_FAILED,\n    CLEAR_GIFS_LIST,\n    COPY_GIF_SUCCESS,\n    COPY_GIF_FAILED\n}\n\n\n","// 1 operation == X actions, e.g. an async request with thunk would be at least 3 actions\n// this is the interface for our actions, and the interface for our duck\n// a thunk will dispatch here, while an operation with only 1 action, will link to that action\nimport * as actions from './actions';\n\nconst changeSearchField = actions.changeSearchField;\n\n// sendRequestGif --> async, so its a thunk, we therefore use return function \nconst sendRequestGif = (searchString) => (dispatch) => {\n    dispatch(actions.sendRequestGifPending());\n\n    fetch('https://api.giphy.com/v1/gifs/search?api_key=Hd1fR0FW1u2HXkBFYL1jVNXIub1V081Y&q=' + searchString + '&limit=100&offset=0&rating=G&lang=en')\n    .then(response => response.json())\n    .then(response => {\n        // filter for size, less than 2.1 mb\n        const sortedData = [];\n        response.data.forEach(gifObject => {\n            if(gifObject.images.original.size <= 2100000){\n                sortedData.push(gifObject)\n            }\n        });\n        dispatch(actions.sendRequestGifSuccess(sortedData));\n    })\n    .catch(error => {\n        dispatch(actions.sendRequestGifFailed());\n    });\n}\n \nconst clearGifsList = actions.clearGifsList;\n\nconst gifClicked = (dispatch, elementId, gifUrl) => {\n    try{\n        var input = document.createElement('input');\n        input.type = 'text';\n        input.id = elementId;\n        input.value = gifUrl;\n        document.body.appendChild(input);\n        input.select()\n        input.setSelectionRange(0, 99999);\n        document.execCommand('copy');\n        dispatch(actions.copyGifSuccess(input.value));\n    }catch(err){\n        dispatch(actions.copyGifFailed(err));\n    }finally{\n        document.body.removeChild(input);\n    }\n    // TODO: add reducer functions\n}\n\nexport {\n    changeSearchField,\n    sendRequestGif,\n    clearGifsList,\n    gifClicked\n}\n\n\n\n\n\n\n\n\n\n\n\n","import * as types from './types';\n\nconst changeSearchField = (searchString) => ({\n    type: types.CHANGE_SEARCH_FIELD,\n    payload: searchString\n})\n\n// REQUEST_GIF_PENDING,\n// REQUEST_GIF_SUCCESS,\n// REQUEST_GIF_FAILED\n\nconst sendRequestGifPending = () => ({\n    type: types.REQUEST_GIF_PENDING\n})\n\nconst sendRequestGifSuccess = (data) => ({\n    type: types.REQUEST_GIF_SUCCESS,\n    payload: data\n})\n\nconst sendRequestGifFailed = () => ({\n    type: types.REQUEST_GIF_FAILED\n})\n\nconst clearGifsList = () => ({\n    type: types.CLEAR_GIFS_LIST,\n    payload: []    \n})\n\nconst copyGifSuccess = (data) => ({\n    type: types.COPY_GIF_SUCCESS,\n    payload: data\n})\n\nconst copyGifFailed = (data) => ({\n    type: types.COPY_GIF_FAILED,\n    payload: data\n})\n\nexport {\n    changeSearchField,\n    sendRequestGifPending,\n    sendRequestGifSuccess,\n    sendRequestGifFailed,\n    clearGifsList,\n    copyGifSuccess,\n    copyGifFailed\n}\n\n\n\n\n","import reducer from './reducers';\n\nimport * as gifsSelectors from './selectors'\nimport * as gifsOperations from './operations';\nimport * as gifsTypes from './types';\n\nexport {\n    gifsSelectors,\n    gifsOperations,\n    gifsTypes\n}\n\nexport default reducer;","import React from 'react';\nimport {gifsOperations} from '../../state/ducks/gifs';\nimport {connect} from 'react-redux';\n\nconst mapStateToProps = (state) => {\n    return{\n        searchField: state.gifsState.changeSearchFieldReducer.searchField\n    }\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        changeSearchField: (searchString) => dispatch(gifsOperations.changeSearchField(searchString)),\n        sendRequestGif: (searchString) => dispatch(gifsOperations.sendRequestGif(searchString)),\n        clearGifsList: () => dispatch(gifsOperations.clearGifsList())   \n    }\n};\n\n\nconst SearchGif = ({searchField, changeSearchField, sendRequestGif, clearGifsList}) => {\n    let input;\n\n    return(\n        <div>\n            <div className='f-5 ma3'>\n                    Current Search: {searchField}\n            </div>\n            \n            <div className='dib'>\n                <div className='dib'>\n                    <button onClick={clearGifsList}>CLEAR</button>\n                </div>\n\n                <form\n                    onSubmit={(e) => {\n                                e.preventDefault();\n                                if(!input.value.trim()){\n                                    return;\n                                }\n                                changeSearchField(input.value);\n                                sendRequestGif(input.value);\n                            }}\n                >\n                \n                <input\n                    ref={node => {\n                        input = node\n                    }}\n                    id='id_searchField'\n                    className='shadow-3 ma2 pa3 ba b--green bg-lightest-blue' \n                    type='search' \n                    placeholder='type here to search'\n                />\n\n                <button type='submit'>\n                    SEARCH\n                </button>\n\n                </form>\n            </div>\n        </div>\n    );\n}\n\nexport default connect(mapStateToProps,mapDispatchToProps)(SearchGif);\n\n","import React from 'react';\n\n\n// shows a gif\n// you click this component, and the GIF url is copied to clipboard --> function from args\n// \n\nconst Gif = ({ keyProp, urlOriginal, sizeOriginal, gifClicked }) => {\n\n    return(\n        <div className='dib tc bg-light-green br3 pa3 ma2 bw2 shadow-5'>\n            <button onClick={() => gifClicked(keyProp, urlOriginal)}>\n                <img src={urlOriginal} alt='gif' className='pa3' />\n            </button>\n        </div>\n    ) \n}\n\nexport default Gif; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","import React from 'react';\nimport {connect} from 'react-redux';\nimport Gif from '../components/Gif';\nimport {gifsOperations} from '../../state/ducks/gifs';\n\nconst mapStateToProps = (state) => {\n    return {\n        gifs: state.gifsState.requestGifReducer.gifs\n    };\n}\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        gifClicked: (elementId, gifUrl) => gifsOperations.gifClicked(dispatch, elementId, gifUrl) \n    };\n}\n\nconst GifsList = ({ gifs, gifClicked }) => {\n\n\n\n    return (\n        <div>\n            {gifs.map((gif, i) => {\n                if(gif.images.original.size <= 2100000){\n                    return <Gif \n                        key={gif.id}\n                        keyProp={gif.id}\n                        urlOriginal={gif.images.original.url}\n                        sizeOriginal={gif.images.original.size}\n                        gifClicked={gifClicked}\n                        />;\n                }else{\n                    return <p key={gif.id}>size too big</p>;\n                }\n            })}\n\n            <p>{gifs.length}</p>\n\n        </div>\n    )\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(GifsList);","import React, { Component } from 'react';\n// import logo from './logo.svg';\nimport './App.css';\n\nimport SearchGif from './containers/SearchGif';\nimport GifsList from './containers/GifsList';\n\nclass App extends Component {\n\n  render() {\n    return(\n      <div className=\"App\">\n        \n\n        <SearchGif />\n\n        <GifsList />\n\n      </div>\n  )\n  }\n  \n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import {createStore, applyMiddleware, combineReducers} from 'redux';\nimport * as reducers from './ducks'; // import all reducers from ducks/index.js\nimport ThunkMiddleware from 'redux-thunk';\nimport {createLogger} from 'redux-logger';\n\nconst logger = createLogger({\n    level: 'log',\n    collapsed: true\n});\n\nexport default function configureStore(initialState = {}){\n    const rootReducer = combineReducers(reducers);\n    return createStore(\n        rootReducer,\n        initialState,\n        applyMiddleware(ThunkMiddleware, logger)\n    );\n}\n\n\n\n\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './views/App';\nimport * as serviceWorker from './serviceWorker';\n// Provider --> allows components to use connet, and subscribe to the store\nimport {Provider} from 'react-redux';\n// global styles\nimport 'tachyons';\n\n//state\nimport configureStore from './state/store';\nconst reduxStore = configureStore();\n\nReactDOM.render(\n    <Provider store={reduxStore}>\n        <App />\n    </Provider>\n, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}